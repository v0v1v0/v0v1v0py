<div class="container">

<table style="width: 100%;"><tr>
<td>opts_read_json</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create named list of options for parsing R from JSON</h2>

<h3>Description</h3>

<p>Create named list of options for parsing R from JSON
</p>


<h3>Usage</h3>

<pre><code class="language-R">opts_read_json(
  promote_num_to_string = FALSE,
  df_missing_list_elem = NULL,
  obj_of_arrs_to_df = TRUE,
  arr_of_objs_to_df = TRUE,
  str_specials = c("string", "special"),
  num_specials = c("special", "string"),
  int64 = c("string", "double", "bit64"),
  length1_array_asis = FALSE,
  yyjson_read_flag = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>promote_num_to_string</code></td>
<td>
<p>Should numeric values be promoted to strings
when they occur within an array with other string values?  Default: FALSE
means to keep numerics as numeric value and promote the <em>container</em> to
be a <code>list</code> rather than an atomic vector when types are mixed.  If <code>TRUE</code>
then array of mixed string/numeric types will be promoted to all
string values and returned as an atomic character vector.  Set this to <code>TRUE</code>
if you want to emulate the behaviour of <code>jsonlite::fromJSON()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df_missing_list_elem</code></td>
<td>
<p>R value to use when elements are missing in list
columns in data.frames. Default: NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj_of_arrs_to_df</code></td>
<td>
<p>logical. Should a named list of equal-length
vectors be promoted to a data.frame?  Default: TRUE.  If FALSE, then
result will be left as a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arr_of_objs_to_df</code></td>
<td>
<p>logical. Should an array or objects be promoted to a
a data.frame? Default: TRUE. If FALSE, then results will be read as a
list-of-lists.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>str_specials</code></td>
<td>
<p>Should <code>'NA'</code> in a JSON string be converted to the <code>'special'</code>
<code>NA</code> value in R, or left as a <code>'string'</code>.  Default: 'string'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_specials</code></td>
<td>
<p>Should JSON strings 'NA'/'Inf'/'NaN' in a numeric context
be converted to the <code>'special'</code> R numeric values
<code>NA, Inf, NaN</code>, or left as a <code>'string'</code>. Default: 'special'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int64</code></td>
<td>
<p>how to encode large integers which do not fit into R's integer
type.  'string' imports them as a character vector. 'double' will
convert the integer to a double precision numeric value. 'bit64' will
use the 'integer64' type from the 'bit64' package.  Note that the
'integer64' type is a <em>signed</em> integer type, and a warning will
be issued if JSON contains an <em>unsigned</em> integer which cannot
be stored in this type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length1_array_asis</code></td>
<td>
<p>logical. Should JSON arrays with length = 1 be
marked with class <code>AsIs</code>.  Default: FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yyjson_read_flag</code></td>
<td>
<p>integer vector of internal <code>yyjson</code>
options.  See <code>yyjson_read_flag</code> in this package, and read
the yyjson API documentation for more information.  This is considered
an advanced option.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Named list of options for reading JSON
</p>


<h3>See Also</h3>

<p><code>yyjson_read_flag()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">opts_read_json()
</code></pre>


</div>